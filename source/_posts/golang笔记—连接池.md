---
title: golang笔记—连接池
date: 2025-09-12 17:06:56
tags: golang
categories: 后端
cover: http://sona-nyl.oss-cn-hangzhou.aliyuncs.com/img/5.webp
---
## 引入
当我们需要对数据库或者类似的组件进行crud操作时，如果对每次操作都去创建tcp连接并销毁它效率有限，所以我们可以用一个容器存储所有的连接，并分发给需要的协程，这个容器就叫连接池。

## 连接池
容器可以有多种实现，只要选择能存储连接客户端的结构就行，堆和channel比较常见。创建好容器后，至少要实现容器的两个方法：
1. 从连接池中获取合法连接
2. 把连接放回池中
### 获取连接
一种实现方式是不断从池中拿出连接直到连接是健康的为止。这个过程和利用懒删除堆处理查询有点像，容器里有若干连接，有部分可能是不健康的，我们只关注pop出来的连接是否健康，而不pop所有不健康连接。不过要注意的是得声明一下容器的存储上限，避免出现过多无用连接占内存。如果直到容器为空仍然没有健康连接，则自行创建连接。
### 放回连接
由于在每次获取连接时都会判断是否合法，所以只需判断存储是否达到上限再决定是放入还是关闭。
### 健康判定
对于连接判断是否健康，我们可以发送一次心跳来判定，不过我觉得不太好，毕竟对于每次操作都要额外发送一次请求成本有点高，一般情况可以直接设置超时时间来判断是否健康，能搞定大部分连接失效的情况。
## 案例
可以去看看这个仓库的代码，横向对比下来比较好懂的一版
[仓库代码](https://github.com/nange/easypool)